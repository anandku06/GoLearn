# GOLang Theory and Practice

## Why GO?

- fast, lightweight, and much developer-friendly
- in terms of execution speed, GO is much faster same goes for the compilation speed as well

## Basics

- a go program can be of two types :
  1. Executables -> contains code that can be run ; a program
  2. library/packages -> contains programs that get imported from these libraries or packages, these are built by some one and can be used by other programmers for faster productivity ; must be in _lowercase_ and as short as possible
- all files of GO has an extension of .go (e.g. main.go)

```go
    // basic GO structure

    package main

    import "fmt"

    func main(){
        fmt.Println("Hello World!!");
    }
```

- every GO file must have packaga declaration, by convention each executable GO file must have _main_ package and function
- GO supports UTF-8 character encoding.
- Provides Cross Platform Single Binary executables -> GO can generate executable binaries
- a statically typed language : all datatypes are checked during the program compilation
- **GO's Encapsulation** -> when the functions or variables are accessed declared using capital letter, they can be accessed ouside of thier native package, but not when they are declared with lowercase

```bash
    go run <file_name> # runs the executable file ; more faster than build command
    go build <file_name> # used to build the GO file that returns a executable ; here OS is not specified so the executable is for the current OS

    GOOS=windows GOARCH=amd64 go build . # creates the executable for windows OS with amd54 architecture

    ./main # then running the executable will return the same file
```

## go.mod file

- contains some necessary info regarding the project like the current version of GO and the project's folder name, etc.
- also contains dependencies that the project requires for execution
- generated by using

```bash
# go mod init <projectName>
go mod init github.com/anandku06/GoLearns # in my case, generates the mod file with the package name and the version of GO

go get <package_name> # appends any external package that can be used in the mod file

go mod download # all the packages used in the project is fetched in the mod file

```

## functions

```go
    // syntax for a function in GO
    func functionName(parameter1 datatype, parameter2 datatype, ...) return type{
        // body of the function
    }

    // starts with the keyword "func" and the function name
    // parameters are given like "parameter datatype"
    // after parenthesis the function's return type

    // example
    func add(x int, y int) int {
        return a + b
    }

```

- in GO, parameter datatypes are checked during compilation, so defined datatype must be given as args to avoid errors
- can return multiple values at once

## Variables

- in GO, variables are also declared using the **var** keyword along with the variableName and the datatype.
- in GO, a variable is not uninitialised ever, it gets the default value whenever its declared
- many ways to declare variable in GO, outside and inside the function

```go
    // Syntax -> var varName datatype

    // these types are allowed only outside the main function and are initialised with default values
    var isLoggedIn bool // default value is false
    var x, y, z int // if all the vars are of same type , default value is 0

    func main(){
        var i int // allowed but initialised with its default value
        i := 10 // only allowed inside the function
        var i = 10 // this is also allowed
        var i string = "Hello" // this is the extended version where you fixed the datatype, only string datatype is entertained
    }
```

## Datatypes

- in GO, we have:
  1. Basic -> numbers{int, uint, byte, rune, float, complex}, string, bool
  2. Aggregated -> array, struct
  3. Reference (they don't have the data, they refer the data that are in other places in the program) -> pointers, slices, function, channel, maps
  4. interfaces

- **type conversions** is basically done in statically-typed language like GO, no implicit conversion only explicit conversion
- **type inference** : when compiler infers the type of the data implicitly and this type can't be changed in later phases of the program
- **constants** : means can't change its value once assigned, evaluated during compile time, declared using the *const* keyword, can store only **basic datatypes**