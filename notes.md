# GOLang Theory and Practice

## Why GO?
- fast, lightweight, and much developer-friendly
- in terms of execution speed, GO is much faster same goes for the compilation speed as well

## Basics
- a go program can be of two types :
    1. Executables -> contains code that can be run ; a program
    2. library/packages -> contains programs that get imported from these libraries or packages, these are built by some one and can be used by other programmers for faster productivity
- all files of GO has an extension of .go (e.g. main.go)
```go
    // basic GO structure

    package main

    import "fmt"

    func main(){
        fmt.Println("Hello World!!");
    }
```
- every GO file must have packaga declaration, by convention each executable GO file must have *main* package and function
- GO supports UTF-8 character encoding.
- Provides Cross Platform Single Binary executables -> GO can generate executable binaries
```bash
    go run <file_name> # runs the executable file ; more faster than build command
    go build <file_name> # used to build the GO file that returns a executable ; here OS is not specified so the executable is for the current OS

    GOOS=windows GOARCH=amd64 go build . # creates the executable for windows OS with amd54 architecture

    ./main # then running the executable will return the same file
```

## go.mod file
- contains some necessary info regarding the project like the current version of GO and the project's folder name, etc.
- also contains dependencies that the project requires for execution
- generated by using 
```bash
# go mod init <projectName>
go mod init github.com/anandku06/GoLearns # in my case, generates the mod file with the package name and the version of GO

go get <package_name> # appends any external package that can be used in the mod file

go mod download # all the packages used in the project is fetched in the mod file

```